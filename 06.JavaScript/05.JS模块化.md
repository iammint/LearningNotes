# JS模块化
> 将代码拆分成独立的块，然后再把这些块连接起来，可以通过模块模式来实现。
> 
> 块的内部数据/实现是私有的，只是向外暴露一些接口，与其它模块通信

# 软件包packages
软件包是可以复制和安装的一大块代码。它可能包含一个或多个模块，而且包含其依赖的其他软件包的信息。

### Module
- imports(dependencies)
- code
- exports

## 1. 匿名闭包
> 函数是JavaScript唯一的Local Scope
```js
let Module = (function() {
    let _private = "safe now"
    let foo = function() {
        console.log(_private)
    }
    return {
        foo: foo
    }
})()
Module.foo()
console.log(Module._private) //undefined
```

👇以形参的形式引入依赖
```js
let Module = (function($) {
    let _$body = $("body")
    let foo = function() {
        console.log(_$body)
    }
    return {
        foo: foo
    }
})(jQuery)
Module.foo()
//利用window暴露对象，将$和jQuery添加给了window
```

## 2. 为什么要模块化？
1. 避免命名冲突
2. 更好地分离，按需加载
3. 提高复用性
4. 方便维护

### 现实中缺点
页面引入加载js请求过多，依赖模糊，难以维护

## 3. IIFE模式
![alt ](../CSS与img引用/V2/module.png)
```js
//module.js中
let obj = {
    msg: "module",
    foo() {
        console.log("foo", this.msg)
    }
}

//html中
obj.foo()//foo module

//修改msg
obj.msg = "module2"
obj.foo() //foo module2
```

```js
//module.js中
(function(window) {
    let msg = "module3"
    function foo() {
        console.log("foo", msg)
    }
    //暴露接口
    window.module3 = {
        foo: foo
    }
    //window.module3 = {foo}
})(window)
//html中
//此时不能直接在html中修改msg，因为没有接口
module3.foo() //module3
```

```js
//module.js中
(function(window) {
    let msg = "module4"
    function foo() {
        console.log("foo", msg)
    }
    window.module4 = foo
})(window)

//html中
//直接调用
module4() //foo module4
```

## 4. CommonJS
每个JS文件都可以当作一个模块
- 在服务器端，模块的加载是运行时同步加载的
- CommonJS模块语法不能直接在浏览器中运行。因此在浏览器端，模块需要提前编译打包处理




### 4.1 暴露模块
> 暴露的本质：暴露的都是exports对象
1. module.exports = value
2. exports.xxx = value

commonJS模块的主要概念是一个名为require的函数，当你使用依赖项的模块名调用它时，它会确保加载模块并返回接口。

因为加载器将模块代码包装在一个函数中，所以模块会自动获得它们的局部作用域。它们所要做的就是调用require来访问它们的依赖项并将它们的接口放在绑定到exports的对象中。

//在js文件中
```js
let user = require('./module.js') //相对地址
```


## 5. ES modules
- 支持异步Asyn
- 'import'
- 'export'

```js
//import all from utils.js 
import * as utils from './utils'
//only import the first function
import {first} from './utils'
```

//HTML
```js
<script type="module" src="./xxx.js"></script>
```

### 5.1 模块导出
导出模块必须在模块顶级，不能嵌套在某个块中。

1. 命名导出
```js
//命名行内导出
export const baz = 'baz'

//命名子句导出
const foo = 'foo'
export {foo}
//导出时也可以提供别名，但是别名必须在export子语句中的大括号中指定
export {foo as myFoo}
```
2. 默认导出
```js
const foo = 'foo'
export default foo

const foo = 'foo'
const bar = 'bar'
export {foo as default, bar}
```

### 5.2 模块导入
模块可以通过使用import关键字使用其他模块导出的值，import也只能出现在模块的顶级
```js
import {foo} from "./fooModule.js"
```
模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径，必须是纯字符串。

命名导出和默认导出的区别也使导入不同。

1. 导入命名导出的集合
> 命名导出可以使用*批量获取并赋值给保存导出集合的别名
> 
>  指名导入需要将标识符放在import子句中
```js
const foo = "foo", bar = "bar", baz = "baz"
export{foo, bar, baz}

import * as Foo from './foo.js'
console.log(Foo.foo) //foo

import{foo, bar, baz as myBaz} from './foo.js'

```
2. 默认导出的集合可以使用default关键字并提供别名来导入
```js
import {default as foo} from "./foo.js"
```

