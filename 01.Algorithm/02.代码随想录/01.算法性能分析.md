# 1. 时间复杂度分析
> 时间复杂度是一个函数，它定性描述该算法的运行时间。我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的时间。

假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。


## 1.1 什么是大O
> **大O用来表示上界的**，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

但是业内默认大O为一般情况下的复杂度：
![Snipaste_2022-07-07_11-12-17.png](https://media.haochen.me/Snipaste_2022-07-07_11-12-17.png)


## 1.2 不同数据规模的差异
![Snipaste_2022-07-07_11-17-31.png](https://media.haochen.me/Snipaste_2022-07-07_11-17-31.png)

因为大O是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量，所以如果数据规模很小时，会出现用O(n^2)的算法比O(n)的更合适的情况。


所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示：

<font color=yellowgreen>**O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶**</font>


## 1.3 O(logn)中的log是以什么为底？
logn不一定以2为底，它可以以任何数字为底。但我们统一说 logn，也就是**忽略底数的描述**。这是因为大O常数可忽略的性质。

![Snipaste_2022-07-07_11-26-38.png](https://media.haochen.me/Snipaste_2022-07-07_11-26-38.png)

log以i为底n的对数等于log 以j为底n的对数，所以不论底数多少，logn所表达的复杂度不变。

## 1.4 Time Complexity Example
> 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串，字符串长度是m）。
1. Brute Force：O(m^n^2) 

    嵌套for循环遍历两次全部字符串，每个字符串遍历m次

2. 先排对n个字符串按字典序来排序，排序后两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串：O(m × n × log n)

    快速排序时间复杂度为O(nlogn)，快速排序只排一位，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。

    之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。

    对O(m × n × log n + n × m) 进行简化操作后的时间复杂度是 O(m × n × log n)。

# 2. O(n)超时，此时n为多大
> 程序运行时间超过了规定的时间，暂定超时时间为1s

如果n的规模已经足够让$O(n)$算法运行时间超过1s，就应该考虑log(n)的解法了。


## 2.1 从硬件配置看计算机的性能
> 计算机的运算速度主要看CPU的配置

以Lenovo联想Air小新14为例，CPU配置：1.8GHz Intel Core i7

> GHz： 1Hz = 1/s ， 1Hz是CPU的一次脉冲
> 
> - 1GHz（兆赫）= 1000MHz（兆赫）
> 
> - 1MHz（兆赫）= 1百万赫兹

故1GHz = 10亿Hz，表示CPU可以一秒脉冲10亿次，一次脉冲并不能简单地认为是一次CPU运算，而是执行次数。例如1+2=3需要执行4次。

而且计算机的CPU还要执行计算机的其他进程任务。

## 2.2 测试实验
|三点注意事项❗|
|:-:|
|CPU执行每条指令所需时间并不相同|
|由于缓存技术，频繁访问相同地址和访问不相邻运算所需时间不同|
|计算机同时运行多个程序，每个程序中还有不同进程线程抢占资源|

```js
//O(n)
function complexity1(n) {
    let ans = 0
    for(let i=0; i<n; i++) {
        ans++
    }
}


//O(n^2)
function complexity2(n) {
    let ans = 0
    for(let i=0; i<n; i++) {
        for(let j=0; j<n; j++) {
            ans++
        }
    }
}


//O(nlogn)
function complexity3(n) {
    let ans = 0
    for(let i=0; i<n; i++) {
        for(let j=1; j<n; j=j**2) { //注意这里j=1
            ans++
        }
    }
}
```
实验内容：在统一加法运算的情况下，测试不同时间复杂度的运算在不同数据规模下所需的运行时间

测试API：
```js
console.time("timerName") 
console.timeEnd("timerName")
```
<font color="red">in the web browser runtime.</font>

### 1. 测试${O(n)}$
![Snipaste_2022-07-08_06-33-04.png](https://media.haochen.me/Snipaste_2022-07-08_06-33-04.png)

通过${O(n)}$算法，计算机1s内大约可进行1.5* 10^9次运算，可以推测${O(n^2)}$算法1s内大约可处理的数量级规模是1.5*10^9开根号。

### 2. 测试${O(n^2)}$
![Snipaste_2022-07-08_06-48-58.png](https://media.haochen.me/Snipaste_2022-07-08_06-48-58.png)

验证了我们的猜想，再推测一下${O(logn)}$算法1s内大约可处理的数量级规模应该比O(n)少一个数量级。


### 3. 测试${O(nlogn)}$
![Snipaste_2022-07-08_07-08-11.png](https://media.haochen.me/Snipaste_2022-07-08_07-08-11.png)


### 4. 整体测试数据
|时间复杂度|1s内大概可以处理的n的规模|
|:-:|:-:|
|O(n)|1.5*10^9|
|O(n^2)|1.22*10^4.5|
|O(nlogn)|10^8|

## 2.3 总结
第2节分析了Leetcode超时的原因 —— 代码的时间复杂度承载不了n的数量级规模，也从硬件配置上大体分析了CPU的执行速度。

然后亲自完成实验，计算各个时间复杂度算法执行约1s时可承载的n的数量级规模。


