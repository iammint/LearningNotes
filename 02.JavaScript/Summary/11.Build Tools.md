# 1. Package managers —— npm

> What npm does is it allows you to run scripts that hoist that binary package within its scope. 

## 1.1 How to use npm

There are two ways of installing packages locally and globally. 


Generally, you'll want to install locally in the project folder. 
1. `cd < the project folder >`
2. `npm install < package name >`

`npm install < package name >`does two things — first, it downloads all the code from the package into a folder called `node_modules`. Second, it automatically modifies the `package.json `file to keep track of the package as a project dependency.

3. If you'd like to install specific version you can `npm install @2.17.0`

4. Update the lateset version `npm update < package name >`

This is useful later when sharing a project with others — instead of sharing the `node_modules` folder (which can get very large), you only need to share the `package.json` file and other developers can install the required packages automatically with the command   `npm install`.

So if you want to get other's project, just copy it and its `package.json`. then:
1. `npm install` command installs all the dependencies, including regular and dev-dependencies. 
2. `npm install --production` command only installs the regular dependencies.

|Version|^2.17.4|~2.17.4|2.17.4|*|
|:-:|:-:|:-:|:-:|:-:|
|`npm install` after getting others' project|Update the latest minor version|Update the latest patch version|Install the exact version|Install absolutely latest version|

`npm uninstall/remove/rm < package name >`can uninstall the package.

## 1.2 npm version
![Snipaste_2022-07-07_16-09-53.png](https://media.haochen.me/Snipaste_2022-07-07_16-09-53.png)
You can update the second and third one without worry about breaking your code. But for the first major one, your code's probably gonna break. 


## 1.3 link to packages in html

Looking inside the `node_modules` folder, we can see the moment.`min.js` file in the `node_modules/moment/min` directory. This means we can link to the npm downloaded version of `moment.min.js` in the `index.html` file as follows:

```js
  <script src="node_modules/moment/min/moment.min.js"></script>
```

But that’s still pretty inconvenient, so next we’ll take a look at how to automate that process as well.


CommonJS was started with the goal of specifying an ecosystem for JavaScript outside the browser. And the most well-known of implementation of CommonJS modules is node.js. 

Instead of loading all of moment.min.js with an HTML script tag, you can load it directly in the JavaScript file as follows:

```js
//index.js
let moment = require("moment")
```

Again, this is all great for node.js, but if you tried to use the above code in the browser, you’d get an error saying require is not defined. The browser doesn’t have access to the file system. 


# 2. Module bundler —— webpack

> A JavaScript module bundler is a tool that gets around the problem with a build step, which has access to the file system to create a final output that is browser compatible. 

Let’s take a look at how to use webpack to get the above `require('moment')` example working in the browser. First we need to install webpack **into the project**. Webpack itself is an npm package, so we can install it in the project folder from the command line:
 
```
$ npm install webpack webpack-cli --save-dev
```

Now we have webpack and webpack-cli installed as packages in the `node_modules` folder. You can use webpack-cli from the command line as follows:

```
$ ./node_modules/.bin/webpack index.js --mode=development
```

This command will find any `require` and `import`statements, and replace them with the appropriate code to create a single output file (which by default is **dist/main.js**).

Now we can use it in the html.
```js
  <script src="dist/main.js"></script>
```

Note that we’ll need to run the webpack command each time we change `index.js` to other file:
```
$ ./node_modules/.bin/webpack
```


Or we can config the webpack in the `webpack.config.js` file and run `npm run build`.


## What is webpack?
> At its core, webpack is a static module bundler for modern JavaScript applications. 

When webpack processes your application, it internally builds a dependency graph from one or more entry points and then combines every module your project needs into one or more bundles, which are static assets to serve your content from.

![Snipaste_2022-07-09_21-31-51.png](https://media.haochen.me/Snipaste_2022-07-09_21-31-51.png)

## 1. Entry
> An **entry point** indicates which module webpack should use to begin buidling out its **internal dependency graph**. 

After installing webpack, you can use it to create a bundle(get an access from) the command line by adding some scipts to the `scripts` section in the `packages.json` file. 

```json
//difine the start point and end point of the bundle
"scripts": {
    "build": "webpack ./test.js --output-path dist --mode=development"
}
//Now with `webpack.config.js` we don't need to define `entry point` and `output`  in the `packages.json` file.
"scripts": {
    "build": "webpack"
}
//We can compress our code in production mode
"scripts-prod": {
    "build": "webpack --mode=development -p"
}
```

Then run`npm run build` which will create a bundle called `main.js` in the `dist` folder. Finally, you can use the `main.js` file in the html.

```js
//In the html file
//❗You need to add the type="module" to the script tag.
<script src="dist/main.js" type="module"></script>
```

## 2. Output
> An **output** is where webpack will put the bundled files. It defaults to ./dist/main.js for the main output file and to the ./dist folder for any other generated file.

## 3. Loaders
> A **loader** is a piece of code that webpack will run on your code before it gets bundled. Loaders are used to transform other resources into javascript. **Loaders** are also JavaScript modules as npm packages .

At a high level, **loaders** have two properties in your webpack configuration: `test` and `use`.

- The `test` property  is a regular expression that identifies which files should be transformed.
- The `use` property is an array of loaders which will be used to transform the files.

```js
// In the `webpack.config.js` file
module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }]
  }
}
// This tells webpack's loader to use the `raw-loader` to transform all .txt files.
```

Now let's take a look at how to require css and style files in js file. 

1. Use `npm install css-loader style-loaser --save-dev` to install the css-loader and style-loader.
2. Create `style.css` file 
3. In the `webpack.config.js` file, we need to add 
   ```js
       module: {
        rules: [{ test: /\.css$/, use: ['style-loader', 'css-loader'] }]
      }
   ```
4. Then we can run `npm run build` to create the bundle.

### Chaining loaders
> You can use multiple loaders to transform your files.

Loaders always excute from right to left. So if you have a loader that transforms a file into another file, the loader that comes next will be able to use the transformed file.

```js



## 4. webpack.config.js
> A **webpack config** is a file that contains all of the configuration options for webpack. We should create it in the project folder.

Webpack applies its defaults after it requires the config. All in `webpack.config.js` allows you to override any of the default behavior. 

Firt let's make the file constructure clean. We need to create a folder called `src` and delete `main.js`because it will be regenerated when the `npm run build` command is run.

——node.modules

——src

      ——js

      ————test.js

      ————tets2.js

      ————all the moduels

      ——css

      ————style.css


——index.html

——packages.json

——webpack.config.js

Then in the `webpack.config.js` file, we need to add the following:

```js
module.exports = {
    entry: "./src/js/test.js",
    output: {
        filename: "main.js",
        path: __dirname+"/dist"
    },
    module: {
        rules: [{ test: /\.css$/, use: ['style-loader', 'css-loader'] }]
        //test的属性值没有''，use数组中的元素有''
      }
}
```

The paths in the `require` and `import` are needed to change.


## 5. Plugins 
> A `plugin ` is an ES5 `class` which implements an `apply` function. So an instance of `plugin` is a JavaScript object that has an `apply` property in the prototype chain. 

Plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables. **So plugins let you add additional functionality to Compilation and do everything else you'd ever want in webpack.**

In order to use a plugin, you need to `require()` it and add it to the plugins array. Most plugins are customizable through options. Since you can use a plugin multiple times in a configuration for different purposes, you need to create an instance of it by calling it with the `new` operator.

```js
// In the `webpack.config.js` file
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
  plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],
};
```

In the example above, the html-webpack-plugin generates an HTML file for your application and automatically injects all your generated bundles into this file.


# Why webpack?
 We need something that can bundle our code, make it available to the browser, and can handle resources and other assets at the same time. 

> Module bundler lets you write any module format(mixed), compliles them for the browser. 

# How to use webpack?
1. In the `package.json` file, add the following to the `scripts` section:
```json
"scripts": {
    "build": "webpack"
}
```
2. Then run `npm run build` to create the bundle.
    
    We don't even need to config the entry and output 
    for they were default. 

3. We can set mode in advance
```json
"scripts": {
"build": "webpack",
"dev": "npm run webpack -- --mode development",
"prod": "npm run webpack -- --mode production"
}
```

## 1. Debug webpack
1. In the `packages.json` file, add the following to the `scripts` section:
```json
"scripts": {
   "debugthis": "node --inspect --inspect-brk ./src/index.js"
}
```
2. Open Edge and input `edge://inspect` and then click the `Open dedicated DevTools for Node` button.
3. Add breakpoints anywhere you want.


## 2. Watch mode
1. In the `packages.json` file, add the following to the `scripts` section:
```json
"scripts": {
   "watch": "webpack --watch"
}
```
2. Then run `npm run watch` to create the bundle.
   
   The process doesn't exit and it just shows this feedback.

## 3. Tree shaking
Tree shaking is a term commonly used within a JavaScript context to describe the removal of dead code.

It relies on the import and export statements in ES2015 to detect if code modules are exported and imported for use between JavaScript files.

In modern JavaScript applications, we use module bundlers (e.g., webpack or Rollup) to automatically remove dead code when bundling multiple JavaScript files into single files. This is important for preparing code that is production ready, for example with clean structures and minimal file size.

## 4. What's in webpack bundle file?
It's an IIFE! Where's the end? What's being passed into it? That's all the data that's gonna be used inside this IIFE. 

## 5. Environment Variables
> Environment variables are variables that are set in the environment of the application.


## 6. Webpack dev server
1. In the `packages.json` file, add the following to the `scripts` section:
```json
"scripts": {
   "webpack-dev-server": "webpack-dev-server",
   dev: "npm run webpack-dev-server -- --mode development"
}
```
2. Then run `npm run dev` to create the bundle.

