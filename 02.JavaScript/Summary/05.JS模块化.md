# JS模块化
> 将代码拆分成独立的块，然后再把这些块连接起来，可以通过模块模式来实现。
> 
> 块的内部数据/实现是私有的，只是向外暴露一些接口，与其它模块通信

# 软件包packages
软件包是可以复制和安装的一大块代码。它可能包含一个或多个模块，而且包含其依赖的其他软件包的信息。

### Module
- imports(dependencies)
- code
- exports

## 1. 匿名闭包
> 函数是JavaScript唯一的Local Scope
```js
let Module = (function() {
    let _private = "safe now"
    let foo = function() {
        console.log(_private)
    }
    return {
        foo: foo
    }
})()
Module.foo()
console.log(Module._private) //undefined
```

👇以形参的形式引入依赖
```js
let Module = (function($) {
    let _$body = $("body")
    let foo = function() {
        console.log(_$body)
    }
    return {
        foo: foo
    }
})(jQuery)
Module.foo()
//利用window暴露对象，将$和jQuery添加给了window
```

## 2. 为什么要模块化？
1. 避免命名冲突
2. 更好地分离，按需加载
3. 提高复用性
4. 方便维护

### 现实中缺点
页面引入加载js请求过多，依赖模糊，难以维护

## 3. IIFE模式
![alt ](../CSS与img引用/V2/module.png)
```js
//module.js中
let obj = {
    msg: "module",
    foo() {
        console.log("foo", this.msg)
    }
}

//html中
obj.foo()//foo module

//修改msg
obj.msg = "module2"
obj.foo() //foo module2
```

```js
//module.js中
(function(window) {
    let msg = "module3"
    function foo() {
        console.log("foo", msg)
    }
    //暴露接口
    window.module3 = {
        foo: foo
    }
    //window.module3 = {foo}
})(window)
//html中
//此时不能直接在html中修改msg，因为没有接口
module3.foo() //module3
```

```js
//module.js中
(function(window) {
    let msg = "module4"
    function foo() {
        console.log("foo", msg)
    }
    window.module4 = foo
})(window)

//html中
//直接调用
module4() //foo module4
```

## 4. CommonJS
每个JS文件都可以当作一个模块
- 在服务器端，模块的加载是运行时同步加载的
- CommonJS模块语法不能直接在浏览器中运行。因此在浏览器端，模块需要提前编译打包处理




### 4.1 暴露模块
> 暴露的本质：暴露的都是exports对象
1. module.exports = value
2. exports.xxx = value

commonJS模块的主要概念是一个名为require的函数，当你使用依赖项的模块名调用它时，它会确保加载模块并返回接口。

因为加载器将模块代码包装在一个函数中，所以模块会自动获得它们的局部作用域。它们所要做的就是调用require来访问它们的依赖项并将它们的接口放在绑定到exports的对象中。

//在js文件中
```js
let user = require('./module.js') //相对地址
```


## 5. ES modules
- 支持异步Asyn
- 'import'
- 'export'

```js
//import all from utils.js 
import * as utils from './utils'
//only import the first function
import {first} from './utils'
```

//HTML
```js
<script type="module" src="./xxx.js"></script>
```

### 5.1 模块导出
导出模块必须在模块顶级，不能嵌套在某个块中。

1. 命名导出
```js
//命名行内导出
export const baz = 'baz'

//命名子句导出
const foo = 'foo'
export {foo}
//导出时也可以提供别名，但是别名必须在export子语句中的大括号中指定
export {foo as myFoo}
```
2. 默认导出
```js
const foo = 'foo'
export default foo

const foo = 'foo'
const bar = 'bar'
export {foo as default, bar}
```

### 5.2 模块导入
模块可以通过使用import关键字使用其他模块导出的值，import也只能出现在模块的顶级
```js
import {foo} from "./fooModule.js"
```
模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径，必须是纯字符串。

命名导出和默认导出的区别也使导入不同。

1. 导入命名导出的集合
> 命名导出可以使用*批量获取并赋值给保存导出集合的别名
> 
>  指名导入需要将标识符放在import子句中
```js
const foo = "foo", bar = "bar", baz = "baz"
export{foo, bar, baz}

import * as Foo from './foo.js'
console.log(Foo.foo) //foo

import{foo, bar, baz as myBaz} from './foo.js'

```
2. 默认导出的集合可以使用default关键字并提供别名来导入
```js
import {default as foo} from "./foo.js"
```

# 6. Package managers —— npm

There are two ways of installing packages locally and globally. 

![install-packages-locally-globally.png](https://media.haochen.me/install-packages-locally-globally.png)

Generally, you'll want to install locally in the project folder. 

`npm install < package name >`does two things — first, it downloads all the code from the package into a folder called `node_modules`. Second, it automatically modifies the `package.json `file to keep track of the package as a project dependency.

This is useful later when sharing a project with others — instead of sharing the `node_modules` folder (which can get very large), you only need to share the `package.json` file and other developers can install the required packages automatically with the command   `npm install`.

Looking inside the `node_modules` folder, we can see the moment.`min.js` file in the `node_modules/moment/min` directory. This means we can link to the npm downloaded version of `moment.min.js` in the `index.html` file as follows:

```js
  <script src="node_modules/moment/min/moment.min.js"></script>
```

But that’s still pretty inconvenient, so next we’ll take a look at how to automate that process as well.

## 6.1 commonJS
CommonJS was started with the goal of specifying an ecosystem for JavaScript outside the browser. And the most well-known of implementation of CommonJS modules is node.js. 

Instead of loading all of moment.min.js with an HTML script tag, you can load it directly in the JavaScript file as follows:

```js
//index.js
let moment = require("moment")
```

<font color="red" size=5>❗Again, this is all great for node.js, but if you tried to use the above code in the browser, you’d get an error saying require is not defined. The browser doesn’t have access to the file system. </font>


## 6.2 Module bundler —— webpack
A JavaScript module bundler is a tool that gets around the problem with a build step, which has access to the file system to create a final output that is browser compatible. 

Let’s take a look at how to use webpack to get the above `require('moment')` example working in the browser. First we need to install webpack into the project. Webpack itself is an npm package, so we can install it from the command line:
```
$ npm install webpack webpack-cli --save-dev
```

Now we have webpack and webpack-cli installed as packages in the `node_modules` folder. You can use webpack-cli from the command line as follows:
```
$ ./node_modules/.bin/webpack index.js --mode=development
```

This command will find any `require` statements, and replace them with the appropriate code to create a single output file (which by default is **dist/main.js**).

Now we can use it in the html.
```js
  <script src="dist/main.js"></script>
```


Note that we’ll need to run the webpack command each time we change `index.js` to other file:
```
$ ./node_modules/.bin/webpack
```

